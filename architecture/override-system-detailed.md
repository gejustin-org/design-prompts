# Override System Architecture

**Version:** 1.0  
**Status:** Draft  
**Last Updated:** 2025-01-13  
**References:** dspec-final-plan-v3.md (Phase 2.6, Phase 4.4)

---

## Table of Contents

1. [Executive Summary](#executive-summary)
2. [Override File Convention](#1-override-file-convention)
3. [Merge Strategy](#2-merge-strategy)
4. [Conflict Detection](#3-conflict-detection)
5. [Eject Implementation](#4-eject-implementation)
6. [Override Versioning](#5-override-versioning)
7. [Implementation Roadmap](#6-implementation-roadmap)

---

## Executive Summary

The Override System enables developers to customize generated components without losing the benefits of spec-driven generation. It provides a clean separation between generated code (`.gen.tsx`) and human customizations (`.override.tsx`), with a deterministic merge process that produces the final component (`.tsx`).

**Design Principles:**
- Generated code is **never manually edited**
- Overrides are **opt-in and granular**
- Merge conflicts are **detected early** (CI/pre-commit)
- **Ejection is always possible** — no vendor lock-in

---

## 1. Override File Convention

### 1.1 Directory Structure

```
src/components/Button/
├── Button.gen.tsx          # Generated code (DO NOT EDIT)
├── Button.override.tsx     # Human customizations (optional)
├── Button.tsx              # Merged output (auto-generated)
├── Button.test.gen.tsx     # Generated tests
├── Button.test.override.tsx # Test overrides (optional)
├── Button.test.tsx         # Merged tests
├── Button.stories.tsx      # Stories (typically not overridden)
├── index.ts                # Barrel export
└── .dspec/
    ├── manifest.json       # Generation metadata
    ├── merge-map.json      # Override merge mappings
    └── history/            # Generation history (optional)
```

### 1.2 File Naming Convention

| Pattern | Purpose | Editable |
|---------|---------|----------|
| `*.gen.tsx` | Generated source | ❌ Never |
| `*.override.tsx` | Human overrides | ✅ Always |
| `*.tsx` (merged) | Final output | ❌ Auto-generated |
| `.dspec/manifest.json` | Generation metadata | ❌ Auto-generated |

### 1.3 Generated File Header

Every `.gen.tsx` file includes provenance metadata:

```typescript
/**
 * @generated by dspec v1.2.0
 * @spec components/button.yaml@abc123
 * @prompt react/cva-variants@2.1.0
 * @model claude-sonnet-4-20250514
 * @hash def456789
 * @timestamp 2025-03-15T10:30:00Z
 * 
 * ⚠️  DO NOT EDIT THIS FILE DIRECTLY
 * 
 * To customize this component, create Button.override.tsx
 * Documentation: https://dspec.dev/docs/overrides
 */
```

### 1.4 Override File Structure

Override files follow a **declarative override pattern**:

```typescript
// Button.override.tsx
import { Override } from '@org/dspec-runtime';
import type { ButtonProps } from './Button.gen';

/**
 * Override configuration for Button component.
 * Each key targets a specific aspect of the generated component.
 */
export const overrides: Override<ButtonProps> = {
  // Override specific props
  props: {
    // Add new prop not in spec
    'data-analytics-id': {
      type: 'string',
      optional: true,
    },
  },

  // Override variant styles
  variants: {
    primary: {
      // Merge with generated styles
      className: 'custom-primary-modifier',
    },
    // Add new variant not in spec
    brand: {
      backgroundColor: 'var(--brand-color)',
      color: 'white',
    },
  },

  // Override or wrap the render function
  render: (Generated, props) => {
    // Add analytics tracking
    const handleClick = (e: React.MouseEvent) => {
      trackEvent('button_click', { id: props['data-analytics-id'] });
      props.onClick?.(e);
    };
    
    return <Generated {...props} onClick={handleClick} />;
  },

  // Override specific internal functions
  functions: {
    getAriaLabel: (original) => (props) => {
      // Custom aria-label logic
      return props.customAriaLabel ?? original(props);
    },
  },
};

export default overrides;
```

### 1.5 Merged Output Structure

The merged `Button.tsx` is auto-generated and combines both sources:

```typescript
/**
 * @merged by dspec v1.2.0
 * @generated Button.gen.tsx@def456
 * @overrides Button.override.tsx@789abc
 * @timestamp 2025-03-15T11:00:00Z
 * 
 * This file is auto-generated from Button.gen.tsx + Button.override.tsx
 * Do not edit directly. Edit Button.override.tsx for customizations.
 */

import { forwardRef } from 'react';
import { cva, type VariantProps } from 'class-variance-authority';
import { applyOverrides } from '@org/dspec-runtime';
import generatedComponent from './Button.gen';
import overrides from './Button.override';

// Merged component with overrides applied
export const Button = applyOverrides(generatedComponent, overrides);

// Re-export types (merged)
export type { ButtonProps } from './Button.gen';
export type { ButtonOverrideProps } from './Button.override';
```

---

## 2. Merge Strategy

### 2.1 Strategy Comparison

| Approach | Pros | Cons | Verdict |
|----------|------|------|---------|
| **Text-based (patch)** | Simple, language-agnostic | Fragile, breaks easily | ❌ Not suitable |
| **AST-based** | Precise, semantic-aware | Complex, slow | ⚠️ For complex cases |
| **Declarative override** | Predictable, fast, type-safe | Learning curve | ✅ **Primary approach** |

### 2.2 Chosen Approach: Declarative Override with AST Fallback

**Primary: Declarative Override Object**
- Overrides are structured objects, not code patches
- Merge is deterministic: apply override object to generated component
- Type-safe: TypeScript validates override structure

**Fallback: AST-based for Complex Cases**
- Used when declarative overrides can't express the customization
- Implemented via `@dspec/ast-merge` for edge cases

### 2.3 Merge Algorithm

```typescript
// packages/dspec-runtime/src/merge.ts

import type { Override, GeneratedComponent } from './types';

interface MergeOptions {
  strategy: 'declarative' | 'ast';
  strict: boolean;  // Fail on unknown override keys
}

export function mergeComponent<P>(
  generated: GeneratedComponent<P>,
  overrides: Override<P>,
  options: MergeOptions = { strategy: 'declarative', strict: true }
): React.ComponentType<P> {
  
  // 1. Validate override structure
  validateOverrides(generated, overrides, options.strict);
  
  // 2. Merge props (add new, override existing)
  const mergedProps = mergeProps(generated.propTypes, overrides.props);
  
  // 3. Merge variants (deep merge)
  const mergedVariants = mergeVariants(generated.variants, overrides.variants);
  
  // 4. Merge functions (wrap or replace)
  const mergedFunctions = mergeFunctions(generated.functions, overrides.functions);
  
  // 5. Apply render wrapper if provided
  const MergedComponent = overrides.render
    ? createWrappedComponent(generated.Component, overrides.render)
    : generated.Component;
  
  // 6. Return merged component
  return Object.assign(MergedComponent, {
    propTypes: mergedProps,
    variants: mergedVariants,
    displayName: generated.displayName,
    __dspec: {
      generated: generated.__dspec,
      overrides: overrides.__meta,
      mergedAt: new Date().toISOString(),
    },
  });
}
```

### 2.4 Merge Operations Detail

#### Props Merge
```typescript
// Strategy: Union with override precedence
function mergeProps(generated, overrides) {
  return {
    ...generated,           // Base props from spec
    ...overrides,           // Override additions/modifications
  };
}

// Example:
// Generated: { variant, size, disabled }
// Override:  { size: { ...newDef }, analyticsId }
// Result:    { variant, size: { ...newDef }, disabled, analyticsId }
```

#### Variants Merge
```typescript
// Strategy: Deep merge with override precedence
function mergeVariants(generated, overrides) {
  const result = { ...generated };
  
  for (const [variant, styles] of Object.entries(overrides ?? {})) {
    if (variant in result) {
      // Existing variant: deep merge
      result[variant] = deepMerge(result[variant], styles);
    } else {
      // New variant: add directly
      result[variant] = styles;
    }
  }
  
  return result;
}

// Example:
// Generated: { primary: { bg: 'blue' }, secondary: { bg: 'gray' } }
// Override:  { primary: { shadow: 'lg' }, brand: { bg: 'purple' } }
// Result:    { primary: { bg: 'blue', shadow: 'lg' }, secondary: { bg: 'gray' }, brand: { bg: 'purple' } }
```

#### Function Merge
```typescript
// Strategy: Wrapper pattern
function mergeFunctions(generated, overrides) {
  const result = { ...generated };
  
  for (const [name, overrideFn] of Object.entries(overrides ?? {})) {
    if (name in result) {
      // Wrap existing function
      const original = result[name];
      result[name] = (...args) => overrideFn(original)(...args);
    } else {
      // New function
      result[name] = overrideFn(null);
    }
  }
  
  return result;
}
```

### 2.5 AST-Based Merge (Fallback)

For cases where declarative overrides are insufficient:

```typescript
// packages/dspec-ast-merge/src/merge.ts

import { parse, traverse, generate } from '@babel/core';
import type { MergeOperation } from './types';

interface ASTMergeConfig {
  operations: MergeOperation[];
  preserveComments: boolean;
  formatOutput: boolean;
}

export function astMerge(
  generatedCode: string,
  overrideCode: string,
  config: ASTMergeConfig
): string {
  const generatedAST = parse(generatedCode, { sourceType: 'module' });
  const overrideAST = parse(overrideCode, { sourceType: 'module' });
  
  for (const operation of config.operations) {
    switch (operation.type) {
      case 'replace_function':
        replaceFunctionInAST(generatedAST, operation);
        break;
      case 'inject_import':
        injectImport(generatedAST, operation);
        break;
      case 'wrap_component':
        wrapComponent(generatedAST, overrideAST, operation);
        break;
      case 'modify_jsx':
        modifyJSX(generatedAST, operation);
        break;
    }
  }
  
  return generate(generatedAST, { 
    retainLines: true,
    comments: config.preserveComments,
  }).code;
}
```

**When to use AST merge:**
- Modifying JSX structure (adding wrapper elements)
- Injecting middleware/interceptors
- Complex conditional rendering changes
- When declarative pattern can't express the need

---

## 3. Conflict Detection

### 3.1 Conflict Types

| Type | Description | Severity | Resolution |
|------|-------------|----------|------------|
| **Structural** | Override targets removed code | Error | Update override |
| **Type** | Override type incompatible | Error | Fix types |
| **Semantic** | Override may conflict with new behavior | Warning | Review |
| **Deprecated** | Override uses deprecated feature | Warning | Migrate |

### 3.2 Detection Pipeline

```
┌─────────────────┐     ┌──────────────────┐     ┌─────────────────┐
│  Spec Change    │────▶│  Generate .gen   │────▶│  Detect Deltas  │
└─────────────────┘     └──────────────────┘     └────────┬────────┘
                                                          │
                        ┌──────────────────┐              │
                        │  Load .override  │◀─────────────┘
                        └────────┬─────────┘
                                 │
                        ┌────────▼─────────┐
                        │  Conflict Check  │
                        └────────┬─────────┘
                                 │
            ┌────────────────────┼────────────────────┐
            ▼                    ▼                    ▼
     ┌─────────────┐      ┌─────────────┐      ┌─────────────┐
     │  No Conflict │      │   Warning   │      │    Error    │
     │   → Merge    │      │ → Merge+Log │      │ → Fail Build│
     └─────────────┘      └─────────────┘      └─────────────┘
```

### 3.3 Conflict Detection Implementation

```typescript
// packages/dspec-cli/src/conflict-detector.ts

import { diff } from 'deep-diff';
import type { GeneratedMeta, OverrideMeta, Conflict } from './types';

interface ConflictReport {
  component: string;
  conflicts: Conflict[];
  warnings: Conflict[];
  canAutoResolve: boolean;
}

export function detectConflicts(
  previousGen: GeneratedMeta,
  currentGen: GeneratedMeta,
  override: OverrideMeta
): ConflictReport {
  const conflicts: Conflict[] = [];
  const warnings: Conflict[] = [];
  
  // 1. Detect removed targets
  const removedExports = findRemovedExports(previousGen, currentGen);
  for (const removed of removedExports) {
    if (override.targets.includes(removed)) {
      conflicts.push({
        type: 'structural',
        severity: 'error',
        message: `Override targets '${removed}' which no longer exists in generated code`,
        target: removed,
        suggestion: `Remove or update override for '${removed}'`,
      });
    }
  }
  
  // 2. Detect type mismatches
  for (const [target, overrideType] of Object.entries(override.propTypes)) {
    const genType = currentGen.propTypes[target];
    if (genType && !isTypeCompatible(genType, overrideType)) {
      conflicts.push({
        type: 'type',
        severity: 'error',
        message: `Override type for '${target}' incompatible with generated type`,
        target,
        expected: genType,
        actual: overrideType,
        suggestion: `Update override type from '${overrideType}' to '${genType}'`,
      });
    }
  }
  
  // 3. Detect semantic conflicts (behavioral changes)
  const behaviorChanges = detectBehaviorChanges(previousGen, currentGen);
  for (const change of behaviorChanges) {
    if (override.targets.includes(change.target)) {
      warnings.push({
        type: 'semantic',
        severity: 'warning',
        message: `Generated behavior changed for '${change.target}' which has override`,
        target: change.target,
        change: change.description,
        suggestion: 'Review override to ensure compatibility with new behavior',
      });
    }
  }
  
  // 4. Detect deprecated feature usage
  for (const target of override.targets) {
    if (currentGen.deprecated?.includes(target)) {
      warnings.push({
        type: 'deprecated',
        severity: 'warning',
        message: `Override uses deprecated feature '${target}'`,
        target,
        suggestion: currentGen.migrations?.[target] ?? 'See migration guide',
      });
    }
  }
  
  return {
    component: currentGen.componentName,
    conflicts,
    warnings,
    canAutoResolve: conflicts.length === 0,
  };
}
```

### 3.4 CI Integration

```yaml
# .github/workflows/dspec-check.yml

name: dspec Conflict Detection

on:
  pull_request:
    paths:
      - 'specs/**'
      - 'src/components/**/*.override.tsx'

jobs:
  conflict-check:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          
      - name: Install dependencies
        run: npm ci
        
      - name: Generate components
        run: npx dspec generate --dry-run
        
      - name: Check for conflicts
        id: conflict-check
        run: |
          npx dspec check-conflicts --format=json > conflicts.json
          if [ $(jq '.errors | length' conflicts.json) -gt 0 ]; then
            echo "has_errors=true" >> $GITHUB_OUTPUT
          fi
          
      - name: Comment PR with conflicts
        if: steps.conflict-check.outputs.has_errors == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const conflicts = require('./conflicts.json');
            const body = formatConflictReport(conflicts);
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body
            });
            
      - name: Fail if errors
        if: steps.conflict-check.outputs.has_errors == 'true'
        run: exit 1
```

### 3.5 Developer Notification

```typescript
// packages/dspec-cli/src/notify.ts

interface NotificationConfig {
  slack?: { webhook: string; channel: string };
  email?: { recipients: string[] };
  github?: { createIssue: boolean };
}

export async function notifyConflict(
  report: ConflictReport,
  config: NotificationConfig
): Promise<void> {
  const message = formatConflictMessage(report);
  
  if (config.slack) {
    await sendSlackNotification(config.slack, message);
  }
  
  if (config.email) {
    await sendEmailNotification(config.email, message);
  }
  
  if (config.github?.createIssue && report.conflicts.length > 0) {
    await createGitHubIssue({
      title: `[dspec] Override conflict in ${report.component}`,
      body: message,
      labels: ['dspec', 'override-conflict'],
    });
  }
}

function formatConflictMessage(report: ConflictReport): string {
  return `
## Override Conflict Detected: ${report.component}

### Errors (${report.conflicts.length})
${report.conflicts.map(c => `
- **${c.type}**: ${c.message}
  - Target: \`${c.target}\`
  - Suggestion: ${c.suggestion}
`).join('')}

### Warnings (${report.warnings.length})
${report.warnings.map(w => `
- **${w.type}**: ${w.message}
  - Target: \`${w.target}\`
  - Suggestion: ${w.suggestion}
`).join('')}

### Action Required
${report.canAutoResolve 
  ? 'Warnings only. Review and merge if acceptable.'
  : 'Errors must be resolved before merge. Update override files.'}
`.trim();
}
```

---

## 4. Eject Implementation

### 4.1 Eject Command Overview

```bash
# Basic eject
dspec eject Button

# Eject with options
dspec eject Button \
  --keep-metadata        # Keep generation comments
  --output ./ejected/    # Custom output directory
  --include-tests        # Also eject test files
  --include-stories      # Also eject stories
  
# Eject all components
dspec eject --all

# Dry run (preview)
dspec eject Button --dry-run
```

### 4.2 Eject Process Flow

```
┌─────────────────────────────────────────────────────────────────┐
│                       dspec eject Button                        │
└─────────────────────────────────────────────────────────────────┘
                                │
                                ▼
┌─────────────────────────────────────────────────────────────────┐
│  1. Load merged component (Button.tsx)                          │
└─────────────────────────────────────────────────────────────────┘
                                │
                                ▼
┌─────────────────────────────────────────────────────────────────┐
│  2. Resolve all dspec runtime imports                           │
│     - Replace @org/dspec-runtime with inline code               │
│     - Inline variant definitions                                │
│     - Remove merge helpers                                      │
└─────────────────────────────────────────────────────────────────┘
                                │
                                ▼
┌─────────────────────────────────────────────────────────────────┐
│  3. Remove generation metadata (unless --keep-metadata)         │
│     - Strip @generated comments                                 │
│     - Remove __dspec properties                                 │
└─────────────────────────────────────────────────────────────────┘
                                │
                                ▼
┌─────────────────────────────────────────────────────────────────┐
│  4. Output standalone component                                 │
│     - Single file or keep structure                             │
│     - No dspec dependencies                                     │
└─────────────────────────────────────────────────────────────────┘
                                │
                                ▼
┌─────────────────────────────────────────────────────────────────┐
│  5. Update dspec manifest                                       │
│     - Mark component as ejected                                 │
│     - Remove from generation pipeline                           │
└─────────────────────────────────────────────────────────────────┘
```

### 4.3 Eject Implementation

```typescript
// packages/dspec-cli/src/commands/eject.ts

import { parse, traverse, generate } from '@babel/core';
import { resolve, dirname, join } from 'path';
import { writeFile, readFile, mkdir } from 'fs/promises';
import type { EjectOptions, EjectResult } from '../types';

export async function ejectComponent(
  componentName: string,
  options: EjectOptions
): Promise<EjectResult> {
  const componentDir = resolve(options.componentsDir, componentName);
  
  // 1. Load source files
  const mergedPath = join(componentDir, `${componentName}.tsx`);
  const mergedCode = await readFile(mergedPath, 'utf-8');
  
  // 2. Parse and transform
  const ast = parse(mergedCode, {
    sourceType: 'module',
    plugins: ['typescript', 'jsx'],
  });
  
  // 3. Remove dspec imports and inline runtime
  const transformed = transformForEject(ast, {
    removeMetadata: !options.keepMetadata,
    inlineRuntime: true,
  });
  
  // 4. Generate output
  const ejectedCode = generate(transformed, {
    retainLines: false,
    comments: options.keepMetadata,
  }).code;
  
  // 5. Format with prettier
  const formattedCode = await formatCode(ejectedCode);
  
  // 6. Add eject header
  const finalCode = addEjectHeader(formattedCode, componentName, options);
  
  // 7. Write output
  const outputDir = options.output ?? componentDir;
  await mkdir(outputDir, { recursive: true });
  await writeFile(join(outputDir, `${componentName}.tsx`), finalCode);
  
  // 8. Update manifest
  await updateManifestForEject(componentDir, componentName);
  
  // 9. Handle tests and stories if requested
  if (options.includeTests) {
    await ejectTests(componentDir, outputDir, componentName, options);
  }
  if (options.includeStories) {
    await ejectStories(componentDir, outputDir, componentName, options);
  }
  
  // 10. Clean up dspec files if not keeping
  if (!options.keepDspecFiles) {
    await cleanupDspecFiles(componentDir, componentName);
  }
  
  return {
    component: componentName,
    outputPath: join(outputDir, `${componentName}.tsx`),
    ejectedFiles: collectEjectedFiles(outputDir, componentName, options),
    removedFromPipeline: true,
  };
}

function transformForEject(ast: any, options: TransformOptions): any {
  traverse(ast, {
    // Remove dspec import declarations
    ImportDeclaration(path) {
      if (path.node.source.value.includes('@org/dspec-runtime')) {
        path.remove();
      }
    },
    
    // Remove __dspec properties
    ObjectProperty(path) {
      if (
        path.node.key.type === 'Identifier' &&
        path.node.key.name === '__dspec'
      ) {
        if (options.removeMetadata) {
          path.remove();
        }
      }
    },
    
    // Inline applyOverrides calls
    CallExpression(path) {
      if (
        path.node.callee.type === 'Identifier' &&
        path.node.callee.name === 'applyOverrides'
      ) {
        // Replace with inlined merged component
        const [generated, overrides] = path.node.arguments;
        path.replaceWith(inlineMergedComponent(generated, overrides));
      }
    },
    
    // Remove @generated comments
    enter(path) {
      if (options.removeMetadata && path.node.leadingComments) {
        path.node.leadingComments = path.node.leadingComments.filter(
          comment => !comment.value.includes('@generated')
        );
      }
    },
  });
  
  return ast;
}

function addEjectHeader(code: string, componentName: string, options: EjectOptions): string {
  if (options.keepMetadata) {
    return `/**
 * Ejected from dspec on ${new Date().toISOString()}
 * Original spec: ${options.specPath}
 * 
 * This component is now fully owned by the consumer.
 * It will no longer receive updates from the design spec.
 */

${code}`;
  }
  
  return `/**
 * ${componentName} Component
 * 
 * Previously generated by dspec. Now fully owned by this codebase.
 */

${code}`;
}

async function cleanupDspecFiles(componentDir: string, componentName: string): Promise<void> {
  const filesToRemove = [
    `${componentName}.gen.tsx`,
    `${componentName}.override.tsx`,
    `${componentName}.test.gen.tsx`,
    `${componentName}.test.override.tsx`,
    '.dspec',
  ];
  
  for (const file of filesToRemove) {
    const filePath = join(componentDir, file);
    await rm(filePath, { recursive: true, force: true });
  }
}
```

### 4.4 Ejected Output Example

**Before (with dspec):**
```typescript
// Button.tsx (merged)
import { applyOverrides } from '@org/dspec-runtime';
import generatedComponent from './Button.gen';
import overrides from './Button.override';

export const Button = applyOverrides(generatedComponent, overrides);
```

**After (ejected):**
```typescript
// Button.tsx (standalone)
/**
 * Button Component
 * 
 * Previously generated by dspec. Now fully owned by this codebase.
 */

import { forwardRef } from 'react';
import { cva, type VariantProps } from 'class-variance-authority';
import { cn } from '@/lib/utils';

const buttonVariants = cva(
  'inline-flex items-center justify-center rounded-md text-sm font-medium transition-colors',
  {
    variants: {
      variant: {
        primary: 'bg-primary text-primary-foreground hover:bg-primary/90',
        secondary: 'bg-secondary text-secondary-foreground hover:bg-secondary/80',
        destructive: 'bg-destructive text-destructive-foreground hover:bg-destructive/90',
        // Custom variant from override (now inlined)
        brand: 'bg-brand text-white hover:bg-brand/90',
      },
      size: {
        sm: 'h-8 px-3 text-xs',
        md: 'h-10 px-4',
        lg: 'h-12 px-6 text-base',
      },
    },
    defaultVariants: {
      variant: 'primary',
      size: 'md',
    },
  }
);

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  asChild?: boolean;
  // Custom prop from override (now part of interface)
  'data-analytics-id'?: string;
}

export const Button = forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, asChild = false, onClick, ...props }, ref) => {
    // Custom click handler from override (now inlined)
    const handleClick = (e: React.MouseEvent<HTMLButtonElement>) => {
      if (props['data-analytics-id']) {
        trackEvent('button_click', { id: props['data-analytics-id'] });
      }
      onClick?.(e);
    };

    return (
      <button
        className={cn(buttonVariants({ variant, size, className }))}
        ref={ref}
        onClick={handleClick}
        {...props}
      />
    );
  }
);

Button.displayName = 'Button';
```

### 4.5 Post-Eject Manifest Update

```json
// .dspec/manifest.json (after eject)
{
  "version": "1.0.0",
  "components": {
    "Button": {
      "status": "ejected",
      "ejectedAt": "2025-03-15T10:30:00Z",
      "ejectedBy": "developer@example.com",
      "originalSpec": "components/button.yaml@abc123",
      "reason": "Required deep customization beyond override system"
    },
    "Input": {
      "status": "managed",
      "lastGenerated": "2025-03-14T09:00:00Z"
    }
  }
}
```

---

## 5. Override Versioning

### 5.1 Compatibility Tracking

Each override file tracks the spec version it's compatible with:

```typescript
// Button.override.tsx
import { Override, compat } from '@org/dspec-runtime';
import type { ButtonProps } from './Button.gen';

// Declare compatibility range
export const metadata = compat({
  specVersion: '^1.2.0',  // Compatible with spec 1.2.x
  generatorVersion: '^2.0.0',
  minFields: ['variant', 'size'],  // Required fields in generated code
});

export const overrides: Override<ButtonProps> = {
  // ... override definitions
};
```

### 5.2 Version Manifest

```json
// .dspec/versions.json
{
  "schema": "1.0.0",
  "components": {
    "Button": {
      "spec": {
        "current": "1.2.3",
        "history": [
          { "version": "1.2.0", "date": "2025-03-01" },
          { "version": "1.1.0", "date": "2025-02-15" },
          { "version": "1.0.0", "date": "2025-02-01" }
        ]
      },
      "override": {
        "compatibleWith": "^1.2.0",
        "testedWith": ["1.2.0", "1.2.1", "1.2.3"],
        "lastUpdated": "2025-03-10"
      },
      "breaking": [
        {
          "version": "1.2.0",
          "changes": ["Renamed 'type' prop to 'variant'"],
          "migrationPath": "Update overrides targeting 'type' to 'variant'"
        }
      ]
    }
  }
}
```

### 5.3 Compatibility Checker

```typescript
// packages/dspec-cli/src/version-check.ts

import semver from 'semver';
import type { VersionManifest, CompatibilityResult } from './types';

export function checkCompatibility(
  componentName: string,
  manifest: VersionManifest
): CompatibilityResult {
  const component = manifest.components[componentName];
  if (!component) {
    return { compatible: true, reason: 'No version tracking for component' };
  }
  
  const { spec, override } = component;
  
  // Check if current spec version satisfies override compatibility
  if (!semver.satisfies(spec.current, override.compatibleWith)) {
    return {
      compatible: false,
      reason: `Override compatible with ${override.compatibleWith}, but spec is ${spec.current}`,
      breaking: findBreakingChanges(component, override.compatibleWith),
      suggestion: 'Update override to be compatible with new spec version',
    };
  }
  
  // Check if tested
  if (!override.testedWith.includes(spec.current)) {
    return {
      compatible: true,
      warning: `Override not explicitly tested with spec ${spec.current}`,
      suggestion: 'Run tests to verify compatibility',
    };
  }
  
  return { compatible: true };
}

function findBreakingChanges(
  component: ComponentVersionInfo,
  compatRange: string
): BreakingChange[] {
  return component.breaking.filter(
    change => !semver.satisfies(change.version, compatRange)
  );
}
```

### 5.4 Migration System

```typescript
// packages/dspec-cli/src/migrate.ts

interface Migration {
  from: string;
  to: string;
  component: string;
  transform: (override: Override) => Override;
  description: string;
}

const migrations: Migration[] = [
  {
    from: '1.1.x',
    to: '1.2.0',
    component: 'Button',
    description: 'Rename type prop to variant',
    transform: (override) => {
      if (override.props?.type) {
        override.props.variant = override.props.type;
        delete override.props.type;
      }
      if (override.variants?.type) {
        // Handle variant renames in variants section
        for (const [key, value] of Object.entries(override.variants)) {
          if (value.type) {
            value.variant = value.type;
            delete value.type;
          }
        }
      }
      return override;
    },
  },
];

export async function migrateOverride(
  componentName: string,
  fromVersion: string,
  toVersion: string
): Promise<MigrationResult> {
  const applicableMigrations = migrations.filter(
    m => m.component === componentName &&
         semver.satisfies(fromVersion, m.from) &&
         semver.lte(m.to, toVersion)
  );
  
  if (applicableMigrations.length === 0) {
    return { migrated: false, reason: 'No migrations needed' };
  }
  
  // Load current override
  let override = await loadOverride(componentName);
  
  // Apply migrations in order
  for (const migration of applicableMigrations) {
    console.log(`Applying migration: ${migration.description}`);
    override = migration.transform(override);
  }
  
  // Save migrated override
  await saveOverride(componentName, override);
  
  return {
    migrated: true,
    appliedMigrations: applicableMigrations.map(m => m.description),
  };
}
```

### 5.5 CLI Commands for Versioning

```bash
# Check override compatibility
dspec compat Button
# Output: ✓ Button override compatible with spec 1.2.3

# Check all components
dspec compat --all

# Migrate override to new spec version
dspec migrate Button --from 1.1.0 --to 1.2.0

# Show version history
dspec versions Button
# Output:
# Button Spec Versions:
#   1.2.3 (current) - 2025-03-15
#   1.2.0 - 2025-03-01 [BREAKING]
#   1.1.0 - 2025-02-15
#   1.0.0 - 2025-02-01
#
# Override: compatible with ^1.2.0
# Last tested: 1.2.3
```

---

## 6. Implementation Roadmap

### Phase 2 (Week 4): Basic Override System
- [ ] `.gen.tsx` / `.override.tsx` / `.tsx` file convention
- [ ] Declarative override structure
- [ ] Basic merge algorithm
- [ ] `dspec eject` command (basic)

### Phase 4 (Week 20-24): Full Override System
- [ ] Conflict detection in CI
- [ ] Developer notifications (Slack/GitHub)
- [ ] AST-based merge fallback
- [ ] Override versioning
- [ ] Migration tooling

### Post-Launch: Continuous Improvement
- [ ] Override usage analytics
- [ ] Common override patterns → spec improvements
- [ ] Auto-migration suggestions

---

## Appendix A: Override Patterns Catalog

### A.1 Adding Analytics

```typescript
export const overrides: Override<ButtonProps> = {
  props: {
    'data-analytics-id': { type: 'string', optional: true },
  },
  render: (Generated, props) => {
    const handleClick = (e) => {
      track('click', { id: props['data-analytics-id'] });
      props.onClick?.(e);
    };
    return <Generated {...props} onClick={handleClick} />;
  },
};
```

### A.2 Adding a New Variant

```typescript
export const overrides: Override<ButtonProps> = {
  variants: {
    brand: {
      backgroundColor: 'var(--brand-primary)',
      color: 'white',
      '&:hover': { backgroundColor: 'var(--brand-primary-dark)' },
    },
  },
};
```

### A.3 Wrapping with Provider

```typescript
export const overrides: Override<ButtonProps> = {
  render: (Generated, props) => (
    <TooltipProvider>
      <Tooltip content={props.tooltip}>
        <Generated {...props} />
      </Tooltip>
    </TooltipProvider>
  ),
};
```

### A.4 Conditional Rendering

```typescript
export const overrides: Override<ButtonProps> = {
  render: (Generated, props) => {
    if (props.loading) {
      return (
        <Generated {...props} disabled>
          <Spinner size="sm" />
          {props.children}
        </Generated>
      );
    }
    return <Generated {...props} />;
  },
};
```

---

## Appendix B: Error Messages

| Error Code | Message | Resolution |
|------------|---------|------------|
| `DSPEC_OVERRIDE_001` | Override targets non-existent export | Remove or update target in override |
| `DSPEC_OVERRIDE_002` | Type mismatch in override | Fix override type to match generated |
| `DSPEC_OVERRIDE_003` | Circular override dependency | Restructure override hierarchy |
| `DSPEC_EJECT_001` | Cannot eject component with dependents | Eject dependents first or use --force |
| `DSPEC_VERSION_001` | Override incompatible with spec version | Run `dspec migrate` or update manually |

---

## Appendix C: Configuration Reference

```yaml
# dspec.config.yaml

overrides:
  # Override file location pattern
  pattern: '{component}.override.tsx'
  
  # Merge strategy
  strategy: declarative  # or 'ast'
  
  # Strict mode (fail on unknown override keys)
  strict: true
  
  # Version compatibility check
  versionCheck: true
  
eject:
  # Default output directory
  output: './ejected'
  
  # Keep metadata in ejected files
  keepMetadata: false
  
  # Include tests when ejecting
  includeTests: true
  
  # Include stories when ejecting
  includeStories: true

conflicts:
  # CI behavior on conflicts
  ci:
    errors: fail      # fail | warn | ignore
    warnings: warn    # fail | warn | ignore
    
  # Notifications
  notify:
    slack:
      enabled: true
      channel: '#design-system'
    github:
      createIssue: true
      labels: ['dspec', 'override-conflict']
```
