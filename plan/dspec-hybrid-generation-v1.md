# dspec: Hybrid Generation Model

**Insight:** Same architecture as codemod — static transforms for deterministic work, AI for semantic generation.

---

## The Split

```
┌─────────────────────────────────────────────────────────────────────┐
│                           YAML SPECS                                 │
│                                                                      │
│   tokens/colors.yaml    components/button.yaml    patterns/*.yaml   │
└─────────────────────────────────┬───────────────────────────────────┘
                                  │
                                  ▼
┌─────────────────────────────────────────────────────────────────────┐
│                         INTERMEDIATE REP                             │
└──────────────────┬──────────────────────────────┬───────────────────┘
                   │                              │
         ┌─────────▼─────────┐          ┌─────────▼─────────┐
         │   STATIC ENGINE   │          │    AI ENGINE      │
         │                   │          │                   │
         │  • Templates      │          │  • Prompts        │
         │  • Deterministic  │          │  • Semantic       │
         │  • Fast           │          │  • Contextual     │
         │  • Predictable    │          │  • Creative       │
         └─────────┬─────────┘          └─────────┬─────────┘
                   │                              │
                   ▼                              ▼
         ┌───────────────────────────────────────────────────┐
         │                  GENERATED OUTPUT                  │
         │                                                    │
         │   tokens.css (static)    Button.tsx (hybrid)      │
         │   package.json (static)  Button.test.tsx (AI)     │
         │   types.ts (static)      context.md (AI)          │
         └───────────────────────────────────────────────────┘
```

---

## Static Engine

**What:** Template-based generation. Handlebars, EJS, or string interpolation.

**Characteristics:**
- Deterministic (same input → same output)
- Fast (no API calls)
- Predictable (no hallucination risk)
- Auditable (templates are inspectable)

### Static Outputs

| Output | Source | Method |
|--------|--------|--------|
| `tokens.css` | tokens/*.yaml | Template: iterate tokens, emit CSS vars |
| `tokens.ts` | tokens/*.yaml | Template: iterate tokens, emit TS consts |
| `tokens.swift` | tokens/*.yaml | Template: iterate tokens, emit Swift |
| `figma-tokens.json` | tokens/*.yaml | Template: map to Figma format |
| `package.json` | config + components | Template: standard structure |
| `index.ts` (exports) | component list | Template: export all |
| `types.ts` (shared) | component props | Template: derive from IR |
| Component structure | component.yaml | Template: imports, interface, scaffold |
| Test structure | component.yaml | Template: describe blocks, test shells |
| Story structure | component.yaml | Template: meta, story shells |

### Example: Static Token Generation

```typescript
// generators/static/tokens-css.ts

function generateTokensCSS(tokens: Tokens): string {
  const lines: string[] = [
    '/* Generated by dspec — DO NOT EDIT */',
    '',
    ':root {'
  ];
  
  // Colors
  for (const [category, values] of Object.entries(tokens.colors)) {
    for (const [name, color] of Object.entries(values)) {
      lines.push(`  --color-${category}-${name}: ${color.value};`);
    }
  }
  
  // Spacing
  for (const [name, value] of Object.entries(tokens.spacing)) {
    lines.push(`  --spacing-${name}: ${value}px;`);
  }
  
  // ... etc
  
  lines.push('}');
  return lines.join('\n');
}
```

**No AI needed.** Pure transformation.

---

## AI Engine

**What:** Prompted generation using LLM.

**Characteristics:**
- Semantic (understands intent)
- Contextual (uses full spec context)
- Creative (handles edge cases)
- Variable (may need validation)

### AI Outputs

| Output | Why AI? |
|--------|---------|
| Component implementation | Needs to interpret styling rules, handle interactions |
| Variant logic | Complex conditional styling |
| Accessibility implementation | Semantic decisions about ARIA |
| Test implementations | Needs to understand what to actually test |
| Story implementations | Creative examples, edge cases |
| Documentation prose | Natural language descriptions |
| Pattern compositions | How components combine |
| context.md | AI-optimized documentation |

### Example: AI Component Generation

```typescript
// generators/ai/component.ts

async function generateComponent(
  component: ComponentIR,
  tokens: Tokens,
  options: AIOptions
): Promise<string> {
  
  const prompt = `
You are generating a React component from a design spec.

## Component Spec
${yaml.dump(component)}

## Available Tokens
${yaml.dump(tokens)}

## Requirements
- Use CVA (class-variance-authority) for variants
- Use Tailwind CSS with CSS variable references
- Include forwardRef
- Handle all states: ${component.states.join(', ')}
- Implement accessibility: ${yaml.dump(component.accessibility)}

## Output Format
Return ONLY the TypeScript code, no explanations.
Include:
1. Imports
2. CVA variants definition
3. Props interface (exported)
4. Component with forwardRef (exported)

Generate the component:
`;

  const response = await ai.generate({
    model: options.model,
    prompt,
    temperature: 0.2, // Low temp for code
  });
  
  return response.content;
}
```

### Example: AI Test Generation

```typescript
// generators/ai/tests.ts

async function generateTests(
  component: ComponentIR,
  componentCode: string,
  options: AIOptions
): Promise<string> {
  
  const prompt = `
You are generating tests for a React component.

## Component Spec
${yaml.dump(component)}

## Component Code
\`\`\`tsx
${componentCode}
\`\`\`

## Required Test Cases (from spec)
${component.tests.map(t => `- ${t.name}: ${t.assert}`).join('\n')}

## Requirements
- Use Vitest and @testing-library/react
- Use userEvent for interactions
- Test each variant: ${component.variants.map(v => v.name).join(', ')}
- Test each size: ${component.sizes?.join(', ') || 'N/A'}
- Test accessibility (focus, ARIA)

Generate comprehensive tests:
`;

  const response = await ai.generate({
    model: options.model,
    prompt,
    temperature: 0.2,
  });
  
  return response.content;
}
```

---

## Hybrid Files

Some files are **hybrid** — static scaffold with AI-filled sections.

### Example: Component File

```typescript
// generators/hybrid/component.ts

async function generateComponentHybrid(
  component: ComponentIR,
  tokens: Tokens
): Promise<string> {
  
  // STATIC: File header
  const header = `
/**
 * Generated by dspec v1.0.0
 * Source: components/${component.name.toLowerCase()}.yaml
 * DO NOT EDIT — regenerate with: dspec generate
 */
`;

  // STATIC: Imports
  const imports = generateImports(component); // Template-based
  
  // STATIC: Props interface
  const propsInterface = generatePropsInterface(component); // Template-based
  
  // AI: CVA variants (complex styling logic)
  const cvaVariants = await generateCVAVariants(component, tokens);
  
  // AI: Component implementation (interactions, accessibility)
  const implementation = await generateImplementation(component);
  
  // STATIC: Export and displayName
  const footer = `
${component.name}.displayName = '${component.name}';
`;

  return [header, imports, cvaVariants, propsInterface, implementation, footer].join('\n\n');
}
```

---

## Validation Layer

AI output needs validation. Static output doesn't.

```typescript
// generators/validate.ts

async function validateGenerated(file: GeneratedFile): Promise<ValidationResult> {
  const checks: Check[] = [];
  
  if (file.type === 'source') {
    // TypeScript check
    checks.push(await typescriptCheck(file.content));
    
    // ESLint check
    checks.push(await eslintCheck(file.content));
    
    // If AI-generated, extra scrutiny
    if (file.generatedBy === 'ai') {
      // Check for hallucinated imports
      checks.push(await checkImports(file.content));
      
      // Check for token references that don't exist
      checks.push(await checkTokenReferences(file.content));
    }
  }
  
  if (file.type === 'test') {
    // Syntax check
    checks.push(await typescriptCheck(file.content));
    
    // Actually run the tests
    checks.push(await runTests(file.content));
  }
  
  return { file, checks, passed: checks.every(c => c.passed) };
}
```

---

## Regeneration Strategy

### When spec changes:

```
┌─────────────────────────────────────────────────────────────────────┐
│  SPEC CHANGE: button.yaml                                           │
│  Changed: added "ghost" variant                                     │
└─────────────────────────────┬───────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────────┐
│  STATIC REGENERATION (instant)                                      │
│                                                                      │
│  • types.ts — add ghost to variant union                            │
│  • index.ts — no change                                             │
│  • package.json — no change                                         │
└─────────────────────────────┬───────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────────┐
│  AI REGENERATION (targeted)                                         │
│                                                                      │
│  • Button.tsx — regenerate CVA variants section only                │
│  • Button.test.tsx — add test for ghost variant                     │
│  • Button.stories.tsx — add Ghost story                             │
└─────────────────────────────┬───────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────────┐
│  VALIDATION                                                          │
│                                                                      │
│  • TypeScript: ✓                                                    │
│  • ESLint: ✓                                                        │
│  • Tests: ✓                                                         │
└─────────────────────────────────────────────────────────────────────┘
```

### Incremental AI

Don't regenerate everything. Target the change:

```typescript
// generators/incremental.ts

function determineRegenerationScope(
  oldSpec: ComponentIR,
  newSpec: ComponentIR
): RegenerationScope {
  const changes = diff(oldSpec, newSpec);
  
  return {
    // Always static
    types: changes.props || changes.variants,
    
    // AI regeneration needed?
    cvaVariants: changes.variants || changes.styling,
    implementation: changes.props || changes.accessibility || changes.states,
    tests: changes.tests || changes.variants || changes.props,
    stories: changes.variants || changes.props,
  };
}
```

---

## Prompt Engineering

Prompts are versioned and tested.

```
prompts/
├── react/
│   ├── component.md          # Component generation prompt
│   ├── component.test.yaml   # Test cases for prompt quality
│   ├── cva-variants.md       # CVA-specific prompt
│   ├── tests.md              # Test generation prompt
│   └── stories.md            # Story generation prompt
├── swift/
│   └── ...
└── shared/
    ├── accessibility.md      # Accessibility knowledge
    └── patterns.md           # Common patterns
```

### Prompt Testing

```yaml
# prompts/react/component.test.yaml

tests:
  - name: generates valid Button
    input:
      component: fixtures/button.yaml
      tokens: fixtures/tokens.yaml
    expect:
      - contains: "forwardRef"
      - contains: "cva("
      - contains: "aria-disabled"
      - typescript: valid
      
  - name: handles all variants
    input:
      component: fixtures/button.yaml
    expect:
      - contains: "primary:"
      - contains: "secondary:"
      - contains: "destructive:"
```

---

## Configuration

```yaml
# dspec.config.yaml

version: 1

specs:
  tokens: ./specs/tokens
  components: ./specs/components
  patterns: ./specs/patterns

generators:
  react:
    output: ./packages/react
    static:
      tokens: true
      types: true
      exports: true
    ai:
      model: claude-sonnet-4-20250514
      temperature: 0.2
      components: true
      tests: true
      stories: true
      
  swift:
    output: ./packages/ios
    static:
      tokens: true
    ai:
      model: claude-sonnet-4-20250514
      components: true

validation:
  typescript: true
  eslint: true
  runTests: true
  
publish:
  registry: npm
  scope: "@handshake"
```

---

## CLI Updates

```bash
# Generate with explicit mode
dspec generate --target react                    # Default: hybrid
dspec generate --target react --static-only      # No AI, templates only
dspec generate --target react --ai-only          # Only AI portions

# Regenerate specific component
dspec generate --target react --component Button

# Regenerate only tests
dspec generate --target react --tests-only

# Dry run (show what would be generated)
dspec generate --target react --dry-run

# Verbose (show prompts and responses)
dspec generate --target react --verbose
```

---

## Cost Control

AI generation has cost. Strategies:

1. **Cache aggressively** — Same spec + same prompt = cached result
2. **Incremental regeneration** — Only regenerate what changed
3. **Static-first** — Use templates where possible
4. **Batch prompts** — Combine multiple components in one call
5. **Model selection** — Use cheaper models for simple components

```typescript
// generators/ai/cache.ts

const cache = new Map<string, string>();

function cacheKey(spec: ComponentIR, promptVersion: string): string {
  return hash(JSON.stringify(spec) + promptVersion);
}

async function generateWithCache(
  spec: ComponentIR,
  generator: () => Promise<string>
): Promise<string> {
  const key = cacheKey(spec, PROMPT_VERSION);
  
  if (cache.has(key)) {
    return cache.get(key)!;
  }
  
  const result = await generator();
  cache.set(key, result);
  return result;
}
```

---

## Summary

| Aspect | Static | AI |
|--------|--------|-----|
| **Speed** | Instant | Seconds |
| **Cost** | Free | Per-token |
| **Determinism** | 100% | ~95% with validation |
| **Creativity** | None | High |
| **Use for** | Tokens, types, scaffolds | Logic, tests, docs |

**The rule:** If it can be expressed as a template, use static. If it needs reasoning, use AI.
